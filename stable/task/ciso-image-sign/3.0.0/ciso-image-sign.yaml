---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: ciso-image-sign
  labels:
    app.kubernetes.io/version: 3.0.0
spec:
  params:
    - name: registry-region
    - name: image
    - name: image-digest
    - name: continuous-delivery-context-secret
      description: name of the configmap containing the continuous delivery pipeline context secrets
      default: secure-properties
    - name: toolchain-apikey-secret-key
      description: field in the secret that contains the api key used to login to ibmcloud kubernetes service
      default: "api-key"
    - name: vault-secret
      default: vault-secret
    - name: ibmcloud-api
      description: the ibmcloud api
      default: https://cloud.ibm.com
    - name: evidence
      default: 'signature-evidence.json'
    - name: pipeline-debug
      description: Pipeline debug mode
      default: "0"
    - name: break-glass-name
      description: Name of the `ConfigMap` that holds Break-Glass mode settings
      default: environment-properties
    - name: break-glass-key
      description: Key in the `break-glass-name` `ConfigMap` that holds the Break-Glass mode settings
      default: break_glass
    - name: taas-artifactory-user
      description: the TaaS Artifactory user
      default: ""
    - name: taas-artifactory-api-token-secret-key
      description: the TaaS Artifactory token name
      default: "taas-artifactory-token"
    - name: artifactory-primary-service
      description: artifactory primary service
      default: "eu"
    - name: artifactory-docker-repo-name
      description: artifactory docker repo name
      default: ""
    - name: artifactory-sigstore-repo-name
      description: the signature storage repository
      default: ""
    - name: artifactory-signing
      descprition: flag for the image is stored in Artifactory.
      default: "0"
  volumes:
    - name: secrets
      secret:
        secretName: $(params.continuous-delivery-context-secret)
    - name: signing-files
      emptyDir: {}
    - name: sigstore
      emptyDir: {}
    - name: steps-volume
      emptyDir: {}
    - name: image-storage
      emptyDir: {}
  stepTemplate:
    env:
      - name: PIPELINE_DEBUG
        value: $(params.pipeline-debug)
      - name: VAULT_SECRET
        valueFrom:
          secretKeyRef:
            name: $(params.continuous-delivery-context-secret)
            key: $(params.vault-secret)
      - name: IMAGE
        value: $(params.image)
      - name: IMAGE_DIGEST
        value: $(params.image-digest)
      - name: ARTIFACTORY_SIGNING
        value: $(params.artifactory-signing)
  results:
    - name: exit-code
      description: The exit-code of the script
    - name: status
      description: The status based on exit-code
    - name: signature
      description: Signature data file name
    - name: signature-content
      description: the signature data
  steps:
    - name: sign-image
      image: wcp-compliance-automation-team-docker-local.artifactory.swg-devops.com/csso-image-sign:1.0.0@sha256:cb22e6ad6b3469155719f6bf09bde641208a1e349e5ccc09407204bb069f7b4e
      env:
        - name: BREAK_GLASS
          valueFrom:
            configMapKeyRef:
              name: $(params.break-glass-name)
              key: $(params.break-glass-key)
              optional: true
        - name: REGISTRY_REGION
          value: $(params.registry-region)
        - name: API
          value: $(params.ibmcloud-api)
      volumeMounts:
        - mountPath: /secrets
          name: secrets
      script: |
          #!/bin/bash

          set +e

          if [[ -n "$BREAK_GLASS" ]]; then
            echo -n "$(params.evidence)" | tee "$(results.signature.path)"
            echo -n 0 | tee "$(results.exit-code.path)"
            echo -n skipped | tee "$(results.status.path)"
            echo "Break-Glass mode is on, skipping the rest of the task..."
            exit 0
          fi

          if [[ "$ARTIFACTORY_SIGNING" -ne 0 ]]; then
            echo "Step skipped."
            exit 0;
          fi

          export IBM_CLOUD_API_KEY=$(cat "/secrets/$(params.toolchain-apikey-secret-key)")

          TARGET_REGION=$(echo "${REGISTRY_REGION}" | awk -F ":" '{print $NF}')
          ibmcloud login -a "${API}" --apikey "${IBM_CLOUD_API_KEY}" -r "${TARGET_REGION}"

          #REGISTRY_URL - the registry URL e.g. us.icr.io, de.icr.io
          REGISTRY_URL=$(echo "$IMAGE" | cut -f1 -d/)

          network_access=$(curl https://w3.ibm.com)
          if [[ "${network_access}" ]]; then
            echo "CISO service reachable"
          else
            echo "No access to internal network. Check that the worker has access"
          fi

          KEY_NAME="temp.pfx"
          echo "RESTORING KEY DATA"
          echo -n "$VAULT_SECRET" | base64 -d > $KEY_NAME
          mv ./$KEY_NAME /etc/ekm
          echo "****************"

          #extract alias
          ALIAS=$(ucl list | grep -m 1 Private)
          if [[ "$ALIAS" ]]; then
            echo "Certificate found"
          else
            STR=$(ucl list)
            if grep -q "Error" <<< "$STR"; then
              echo "Cannot access CISO partition."
              echo "Ensure that CISO account has been setup and that the client key secret is correct"
            else
              echo "Ensure that your CISO partition has a signing certifcate provisioned"
            fi
          fi
          ALIAS=${ALIAS#*"UID="}
          ALIAS=$(echo $ALIAS | head -n1 | sed -e 's/\s.*$//')
          echo "Alias: $ALIAS"

          gpgconf --kill all
          ucl pgp-key -u ${ALIAS}
          FINGERPRINT=$(gpg2 -k)
          FINGERPRINT=${FINGERPRINT#*"[SCEA]"}
          FINGERPRINT=$(echo $FINGERPRINT | head -n1 | sed -e 's/\s.*$//')
          SIGNING_DIR="signing"
          mkdir ${SIGNING_DIR}

          SIGNING_KEY=${FINGERPRINT}

          if [[ "$SIGNING_KEY" ]]; then
              echo "SIGNING REPO"
              skopeo copy docker://"${IMAGE}" docker://"${IMAGE}" --dest-creds iamapikey:"${IBM_CLOUD_API_KEY}" --src-creds iamapikey:"${IBM_CLOUD_API_KEY}" --sign-by "${SIGNING_KEY}"
          else
              echo "No key found. Unable to sign"
          fi
          PASS=$?
          echo $PASS | tee "$(results.exit-code.path)"
          if [[ "$SIGNING_KEY" && "$PASS" == 0 ]]; then
            echo "No issues were found"
            IAMBEARER=$(ibmcloud iam oauth-tokens | awk '/IAM/ { print $4; }')
            NAME=$(echo "$IMAGE" | cut -d: -f1 | cut -d/ -f2,3)
            TOKEN=$(curl -s \
            -F "service=registry" \
            -F "grant_type=password" \
            -F "client_id=curlsig" \
            -F "username=iambearer" \
            -F "password=${IAMBEARER}" \
            -F "scope=repository:${NAME}:pull" \
            https://${REGISTRY_URL}/oauth/token | jq -r .token)

            SIGNATURES=$(curl -s -H "Authorization: Bearer ${TOKEN}" https://${REGISTRY_URL}/extensions/v2/${NAME}/signatures/${IMAGE_DIGEST} | jq '.signatures')

            COUNT=$(echo "${SIGNATURES}" | jq '. | length')
            INDEX=$(echo "$((COUNT - 1))")
            echo "SIGNATURE INDEX ${INDEX}"

            SIGNATURE_DATA=$(echo "$SIGNATURES" | jq --arg jq_index "$INDEX" '.[$jq_index|tonumber]')
            echo -n success | tee $(results.status.path)

            #create evidence json
            cd /artifacts
            echo "${SIGNATURE_DATA}" > "$(params.evidence)"
            SIGNATURE_CONTENT=$(echo "${SIGNATURE_DATA}" | jq -r '.content')
            echo -n "$(params.evidence)" | tee "$(results.signature.path)"
            echo -n "${SIGNATURE_CONTENT}" | tee "$(results.signature-content.path)"
          else
            echo "Signing failed."
            cd /artifacts
            echo -n failure | tee "$(results.status.path)"
            echo {} > "$(params.evidence)"
            echo -n "$(params.evidence)" | tee "$(results.signature.path)"
          fi

    - name: artifactory-prepare-environment-for-signing
      image: icr.io/continuous-delivery/pipeline/pipeline-base-image:2.6@sha256:7f588468622a981f89cf5e1212aaf75fface9da6169b5345ca52ab63d8215907
      env:
        - name: ARTIFACTORY_API_KEY
          valueFrom:
            secretKeyRef:
              name: $(params.continuous-delivery-context-secret)
              key: $(params.taas-artifactory-api-token-secret-key)
        - name: ARTIFACTORY_PRIMARY_SERVICE
          value: $(params.artifactory-primary-service)
        - name: ARTIFACTORY_DOCKER_REPO_NAME
          value: $(params.artifactory-docker-repo-name)
        - name: ARTIFACTORY_SIGSTORE_REPO_NAME
          value: $(params.artifactory-sigstore-repo-name)
      volumeMounts:
        - mountPath: /secrets
          name: secrets
        - mountPath: /signing-files
          name: signing-files
        - mountPath: /steps
          name: steps-volume
      script: |
          #!/bin/bash
          set +e
          echo "ARTIFACTORY_DOCKER_REPO_NAME $ARTIFACTORY_DOCKER_REPO_NAME"
          echo "ARTIFACTORY_SIGSTORE_REPO_NAME $ARTIFACTORY_SIGSTORE_REPO_NAME"
          if [[ "$ARTIFACTORY_SIGNING" -eq 0 ]]; then
            echo "Step skipped."
            exit 0;
          fi

          export ARTIFACTORY_BASE_URL="https://${ARTIFACTORY_PRIMARY_SERVICE}.artifactory.swg-devops.com/artifactory"
          export ARTIFACTORY_DOCKER_REPO_URL="${ARTIFACTORY_DOCKER_REPO_NAME}.artifactory.swg-devops.com"
          export ARTIFACTORY_SIGSTORE_REPO_URL="${ARTIFACTORY_PRIMARY_SERVICE}.artifactory.swg-devops.com/artifactory/${ARTIFACTORY_SIGSTORE_REPO_NAME}"
          export PUBLIC_KEY_FILE="/signing-files/public-key.pub"

          echo "Creating artifactory.yaml from template (for use at /etc/containers/registries.d/artifactory.yaml)..."

          yq n docker[$ARTIFACTORY_DOCKER_REPO_URL].sigstore https://${ARTIFACTORY_USER}:${ARTIFACTORY_API_KEY}@${ARTIFACTORY_SIGSTORE_REPO_URL} > tmp.yaml
          yq w tmp.yaml docker[$ARTIFACTORY_DOCKER_REPO_URL].sigstore-staging file:///var/lib/containers/sigstore > /signing-files/artifactory.yaml

          cat /signing-files/artifactory.yaml

          jq -n '{default: [{type: $type}], transports: { "docker-daemon": {"": [{type: $type}]}, docker: { ($url): [{type: $signed, keyType: $keytype, keyPath: $keyPath}]}}}' \
          --arg type insecureAcceptAnything \
          --arg url "$ARTIFACTORY_DOCKER_REPO_URL" '.[$url]' \
          --arg signed signedBy \
          --arg keytype GPGKeys \
          --arg keyPath $PUBLIC_KEY_FILE > /signing-files/policy.json

          cat /signing-files/policy.json

          echo "ARTIFACTORY_DOCKER_REPO_URL=${ARTIFACTORY_DOCKER_REPO_URL}" >> /steps/next-step-env.properties
          echo "ARTIFACTORY_BASE_URL=${ARTIFACTORY_BASE_URL}" >> /steps/next-step-env.properties
          echo "ARTIFACTORY_SIGSTORE_REPO_URL=${ARTIFACTORY_SIGSTORE_REPO_URL}" >> /steps/next-step-env.properties
          echo "PUBLIC_KEY_FILE=${PUBLIC_KEY_FILE}" >> /steps/next-step-env.properties
          echo "ARTIFACTORY_DOCKER_REPO_URL $ARTIFACTORY_DOCKER_REPO_URL"
          echo "ARTIFACTORY_BASE_URL $ARTIFACTORY_BASE_URL"
          echo "ARTIFACTORY_SIGSTORE_REPO_URL $ARTIFACTORY_SIGSTORE_REPO_URL"
          echo "PUBLIC_KEY_FILE $PUBLIC_KEY_FILE"

    - name: artifactory-sign-image
      image: wcp-compliance-automation-team-docker-local.artifactory.swg-devops.com/code-signing-agent:1.0.0@sha256:1a77f8002ff5e0f35bfaab52ed1dd93b1ca2277987e7dd5941b64afa3527451d
      env:
        # Ask the jfrog CLI not to offer alternative config options
        - name: JFROG_CLI_OFFER_CONFIG
          value: "false"
        - name: ARTIFACTORY_USER
          value: $(params.taas-artifactory-user)
        - name: ARTIFACTORY_API_KEY
          valueFrom:
            secretKeyRef:
              name: $(params.continuous-delivery-context-secret)
              key: $(params.taas-artifactory-api-token-secret-key)
        - name: ARTIFACTORY_PRIMARY_SERVICE
          value: $(params.artifactory-primary-service)
        - name: ARTIFACTORY_DOCKER_REPO_NAME
          value: $(params.artifactory-docker-repo-name)
        - name: ARTIFACTORY_SIGSTORE_REPO_NAME
          value: $(params.artifactory-sigstore-repo-name)
      volumeMounts:
        - mountPath: /secrets
          name: secrets
        - mountPath: /signing-files
          name: signing-files
        - mountPath: /var/lib/containers/sigstore
          name: sigstore
        - mountPath: /steps
          name: steps-volume
        - mountPath: /image-storage
          name: image-storage
      # yamllint disable rule:line-length
      script: |
          #!/bin/bash
          set -x

          if [[ "$ARTIFACTORY_SIGNING" -eq 0 ]]; then
            echo "Step skipped."
            exit 0;
          fi

          source /steps/next-step-env.properties
          export IBM_CLOUD_API_KEY=$(cat "/secrets/$(params.toolchain-apikey-secret-key)")
          echo "copying images"
          ls /image-storage
          echo "docker://${IMAGE}"
          skopeo copy \
              docker://"${IMAGE}" \
              dir:/image-storage \
              --dest-creds "${ARTIFACTORY_USER}:${ARTIFACTORY_API_KEY}" \
              --src-creds iamapikey:"$IBM_CLOUD_API_KEY"


          echo "show image"
          #ls /image-storage
          cp -p /signing-files/artifactory.yaml  /etc/containers/registries.d/artifactory.yaml
          cp -p /signing-files/policy.json /etc/containers/policy.json
          echo "************************"
          echo "artifactory yaml & policy json"
          #cat /etc/containers/registries.d/artifactory.yaml
          #cat /etc/containers/policy.json
          echo "Generating PFX file from secret"
          echo -n "${VAULT_SECRET}" | base64 --decode > /signing-files/temp.pfx
          chmod 644 /signing-files/temp.pfx

          cp -p /signing-files/temp.pfx /etc/ekm/temp.pfx

          #extract alias
          ALIAS=$(ucl list | grep -m 1 Private)
          if [[ "$ALIAS" ]]; then
            echo "Certificate found"
          else
            STR=$(ucl list)
            if grep -q "Error" <<< "$STR"; then
              echo "Cannot access CISO partition."
              echo "Ensure that CISO account has been setup and that the client key secret is correct"
            else
              echo "Ensure that your CISO partition has a signing certifcate provisioned"
            fi
          fi
          ALIAS=${ALIAS#*"UID="}
          ALIAS=$(echo $ALIAS | head -n1 | sed -e 's/\s.*$//')
          echo "Alias: $ALIAS"

          gpgconf --kill all
          ucl pgp-key -u ${ALIAS}
          FINGERPRINT=$(gpg2 -k)
          FINGERPRINT=${FINGERPRINT#*"[SCEA]"}
          FINGERPRINT=$(echo $FINGERPRINT | head -n1 | sed -e 's/\s.*$//')
          gpg2 --armor --output ${PUBLIC_KEY_FILE} --export ${FINGERPRINT}
          DESTINATION="wcp-delorean-team-docker-local.artifactory.swg-devops.com/myimage_signed:latest"
          #ls /image-storage
          skopeo copy \
              dir:/image-storage \
              docker://"${DESTINATION}" \
              --dest-creds "${ARTIFACTORY_USER}:${ARTIFACTORY_API_KEY}" \
              --remove-signatures \
              --src-creds "${ARTIFACTORY_USER}:${ARTIFACTORY_API_KEY}" \
              --sign-by "${FINGERPRINT}"

          echo "Upload Signature"
          # Ensure there is only one signature folder in the staging sigstore
          NUMBER_OF_FILES=$(ls -1 /var/lib/containers/sigstore | wc -l)
          if [ "$NUMBER_OF_FILES" -ne 1 ]; then
              echo "Expected one file in /var/lib/containers/sigstore but found $NUMBER_OF_FILES files, aborting upload of signature for security. Exiting."
              exit 1
          fi

          # Create a zip file containing only the file structure within the staging sigstore
          cd /var/lib/containers/sigstore/; zip -r /tmp/upload-sig-to-artifactory.zip ./*; cd -
          # Upload the zip file to Artifactory and explode it to replicate the same structure
          jfrog rt u --explode --user "${ARTIFACTORY_USER}" --apikey "${ARTIFACTORY_API_KEY}" --url "${ARTIFACTORY_BASE_URL}" "/tmp/upload-sig-to-artifactory.zip" "${ARTIFACTORY_SIGSTORE_REPO_NAME}"

          # Delete files from our staging sigstore
          rm -rf /var/lib/containers/sigstore/*

          echo "Pull signed image"
          skopeo copy \
            --src-creds "${ARTIFACTORY_USER}:${ARTIFACTORY_API_KEY}" \
            docker://"${DESTINATION}" \
            dir:/tmp/image-signed

          PASS=$?
          echo $PASS | tee $(results.exit-code.path)

          if [ "$PASS" == 0 ]; then
            echo -n success | tee "$(results.status.path)"
            cd /tmp/image-signed
            SIGNATURE_DATA=$(cat signature-1 | base64 -w 0)
            cd ..
            cd /artifacts
            echo "${SIGNATURE_DATA}" > "$(params.evidence)"
            echo -n "$(params.evidence)" | tee "$(results.signature.path)"

            SIGNATURE_CONTENT="${SIGNATURE_DATA}"
            echo -n "${SIGNATURE_CONTENT}" | tee "$(results.signature-content.path)"
          else
            echo -n failure | tee "$(results.status.path)"
            echo {} > "$(params.evidence)"
            echo -n "$(params.evidence)" | tee "$(results.signature.path)"
            echo -n "" | tee "$(results.signature-content.path)"
          fi

  workspaces:
    - name: artifacts
      description: A workspace backing by a volume
      mountPath: /artifacts
